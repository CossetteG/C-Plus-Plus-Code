Notes for C++

prof. Gabriel Raymer
TA Tyler Rees

email the prof. 

Late work- keep it within reason and you'll get credit
Don't be late on projects 
code pretty fires

cobol is used in banking

zybooks- paid for (:
)-has 6 projects

c is the basic assembly
c sharp is an open-source programming language
c+ and c++ have more 

internet has been a normal thing since 1995 

Module 1:

hello world, user input

source file > compile > object file > link > executable file 

cout << (output to console)
cin >> (input from console)  

developing with repl.it 

static and dynamic typing- python is dynamic, c++ is static
you declare the type of the variable up front
size is determined at compile time



Variables and Assignments

built-in: bool, char, int, float, double
integers- short, long, longlong, unsigned, __int8, int16, in32, etc
double replaces float- different bit count ( 32f v 64d )
long double has maximum precision

#include <iostream>
#inclue <iomanip>
#include <math>

using namespace std;

int main(){
    double sphereVolume;
    double sphereRadius;

    cin >> sphereRadius;
}

Numeric Literals- can use ' as a group separator
0b1011'0011'0001'1000   binary
0xB318                  hex
1'000'000               decimal
1.23e5                  decimal

integer division- if both operands are integers, the remainder is dropped
if either is a floating-point, the remainder is kept
    if you cast as integer- it is dropped< narrowing conversion

be careful with compiling too much stuff- you can put everythin in 1 folder tho

int main(){
    int n = 3/2;
    auto m = 3/2.0;
    int k {3/2};
    cout << n << ", " << m << ", " << k << endl;
}

math with large integers can overflow- silent error

signed int - cut the size of the int in half to include its counterparts in negative
unsigned int- normal positive int with a set size 

int main(){
    singed int n = INT_MAX
    cout << n << endl;
    cout << n+1 << endl;

    unsigned int n = INT_MAX
    cout << n << endl;
}

floats are limited to 32 bits, doubles are 64 bits 
as numbers grows bigger, they are spaced further apart

the computer skips integers when numbers get really really big- rounding error
^floating put



Control Flow AKA Switches and IF statements

code-cotta- practicing the same code over and over to get muscle memory for coding

We'll start doing projects will start in February

watchlist- watch the variables to see what it's set to
call stack- where code resides in memory 
use your compiler!!

if..else if..else
the condition must be in parentheses
If you have multiple lanes in a branch, use blocks:
{
    <line 1>
    <line 2>
}

Order of evaluation:
() ! */% +- <><=>= ==!= && ||

m<x<n is not allowed, use m<x && x<n
when in doubt, use parentheses

Bitwise operations
used to access bits of a variable 
-to control aspects of your operating systems hardware
-can save memory in certain applications

| or & and ^ xor ~ not >> shift right << shift left 
be careful to not lose bits 
xor is one or the other but not both 

switches and cases
if / if else / else 

switch (a) {
    case 0:
        //
        break;
    case 1:
        //
        break;
    default:
        //
        break;
}
if you don't have a break statement, it'll read the block and go to the next one 
until it reaches a break 

to get a char at pos k from str s 
s.at(k)  <<checks that the position is valid
s[k]

ternary operators: _?_:_   <Condition>? <TrueResult>:<FalseResult> 
shorthand for an if else that yields a value and can nest

recursion 

fact(n):{
    n==1? cout<<n:fact(n-1);
}


ok lets break down a hello world

#include <iostream>
using namespace std;

int main() {
    cout << "Hello World";
    cout << endl;
}

#include <iostream>
//variable values mostly go in <> I think idk ask later
using namespace std;
// import statements. idk we'll get into it later

char main() {
//char is the return value is supposed to be a character. can also be int or whatever
//main is the main function. most c languages have main every time
//parentheses to denote a function. as per usual
//open curly brackets- anything in the curly brackets is in the function
    cout << "Hello World";
    //cout (c-out) for characters out- basically the print statement
    //the pointer points to the direction the variable is going to 
    //so the "Hello World" variable will go into the cout function 
    cout << endl;
    //another cout to end the line. you could also put in the same line as the first but whatevs
    //technically endl starts a new line 
    //always end your line with ;
}
//always end your func with close curly bracket 

"string literal"

#include <iostream>
using namespace std;

int main() {
   int drivingYear;
   int drivingAge;
   int numStates; 
    //declaring some variables here

   drivingYear = 2014;
   drivingAge = 18;
   numStates = 10; 
    //and setting them some values. No you cannot declare them and set them in the same line

   cout << "In " << drivingYear << " the driving age is " << drivingAge << "." << endl;
    // you can put more stuff in one line by using more pointers
   cout << numStates << " states have exceptions." << endl;
  

   return 0;
}

//single line comment

/*
mulitline or block comment
*/

ERRORS

syntax error aka compile time error:

main.cpp:6:27: error: expected ';' after expression
   cout << "Traffic today" 
                          ^
                          ;

the compiler will give you all the errors it finds in numerical order 
but some errors are side effects of previous errors
so start with the first one it gives you

other errors include logic errors- aka bugs

compilers turn c-language into executable binary code 


Loops 

while- the condition must be in parentheses
do while- the condition is checkd after the loop body runs 
good for undetermined amount of runs

for -start/condition/step or range-based loop 
good for a determined amount of runs 

int i;
while (cin >> i)
  cout << "You entered "<<i<<endl; 
//this code just returns the int you put into it

ctr d to exit loops and stuff 

check your input with while loops 

int i;
cout<<"Enter a number btwn 1-5: ";
cin>>n;
while(n<1||n>5) {
    cout << "Enter num 1-5" ;
    cin >> n;
}
cout << "You entered: " << n << endl:

int n;
do {
    cout<<"Enter a number btwn 1-5:";
    cin>>n;
} while (n<1||n>5) {
    whatever;
}

for loop is technically a shorthand for a while loop 
the scope of loop variables are always contrained to inside the loop 

equivalent loops 

for( int i= 0; i<5; ++i)
    cout<<i<<""; 
    cout<<endl;

string s = "hello";
for (char c:s)
    cout<<c<<endl;
//c is the loop variable it takes on each value of the sequence in turn 

for (char c:input_word) {
    if(isalpha(c)) {
        ++num_letters
    }
}

Truthiness Idiom - a numeric expression is true when it is non-zero 
isalpha nad other <cctype> functions don't return true when its argument is a letter 
as a general rule check for false rather than true 

functions tolower and toupper - they return ints!
to print as characters- cast to char or store in char variable 

break and continue 
break exites the closest enclosing loop
continue cycles on the closest enclosing loop 
^more for error handling 

all named values have a scope - the region where it is visible 
{
    //arbitrary scope
    ::i //global variable 
}

enums are compile-time constants 
enum is like a fancy array /dict 

The syntax for outputting the double myFloat with two digits after the decimal point is
cout << fixed << setprecision(2) << myFloat;
Though C++ does not attempt to output the full value of pi,
 by default, 5 digits after the decimal are output.
fixed and setprecision() are manipulators that need only be written once if the 
desired number of digits after the decimal point is the same for multiple floating-point numbers. Ex:

cout << fixed << setprecision(3) << 3.1244 << endl;
cout << 2.1 << endl;
outputs 3.124 and 2.100.

scientific notation is written using an e preceding the power-of-10 exponent, as in 6.02e23 to represent 6.02 x 1023.
 The e stands for exponent. Likewise, 0.001 is 1 x 10-3 and can be written as 1.0e-3.

A few common math functions from the math library.
Function	Behavior	          Example
sqrt(x)	    Square root of x	  sqrt(9.0) evaluates to 3.0.
pow(x, y)	Power:                pow(6.0, 2.0) evaluates to 36.0.
fabs(x)	    Absolute value of x   fabs(-99.5) evaluates to 99.5.

modulo % is only for integers- it returns the remainder 
anything % 0 is undefined 

randNum % 10
Yields 0 - 9 


Sequences and Functions - Vectors and Arrays

std::vector (like a list in python)
a generic container (variables)
can hold obhects of any type, but ony one type at a time
holds them in a sequence, and can grow at runtime to hold more items
can use indexing and iterators 
vector<int> = (v[0], v[1], v[2] ...)

vectors allocate more memory than needed, so you don't have to reallocate memory everytime you add an element
when memory is exhausted, more memory is allocated
functions: elem space last alloc 

#include <iostream>
#include <vector>
using namespace std;

int main () {
    double time1;
    double time2;
    double time3;
    double time4;
    double time5;

    cin >> time1;
    cin >> time2;
    cin >> time3;
    cin >> time4;
    cin >> time5;

    vector <double> walkingTime = {time1, time2, time3, time4, time5}; 
      //natively C++ doesn't have the = assignment operator 

    for (i = 0; i < walkingTime.size();, ++1) {
        cout << walkingTime.at(i) << " ";
    }
    cout << endl;
}

    vector <int> swimmingListings (numPeople); //a list with the amount of stuff numPeople 
    swimmingListings.at(0) = firstPerson;
    swimmingListings.at(numPeople - 1) = lastPerson;

    //
    cin >>numTime;
    vector <int> bikingLobs(numTime);

    for (i = 0; i < bikingLobs.size(); ++i) {
        cin >> bikingLobs.at(i);
    }

    for (i = 0; i < bikingLobs.size(); ++i) {
        if bikingLobs.at(i) != 9{
            cout << bikingLobs.at(i) << endl;
        }
    }

    //
    for (i = 0; i < numStudents.size(); ++i) {
        if (walkingListings.at(i) % 2 == 0) {
            cout << walkingListings.at(i) << "-";
        }
    }
    cout << endl;

    for (i = 0; i < numStudents.size(); ++i) {
        if (walkingListings.at(i) % 2 == 1) {     //example used != 0
            cout << walkingListings.at(i) << "-";
        }
    }
    cout << endl;

vector<int> v(5); // [0,0,0,0,0] 
to avoid pain points: initalize things with 0 or empty strings as much as possible 

int main(){
    vector<int> myVect(5):
    for (int n:myVect)
        cout << n << ' ';
    cout << endl;
}

cout streams everything into a strings
vector::resize grows a vector 0 for numbers, "" for strings 
    resize  can also shrink your vectors, and extra stuff may or may not stay in memory 
reserve is more efficient, it allowcates memory space to grow your vector 

    vector<int> v = {1,2,3,4,5};
    v.reserve(10);
    for (auto n: v)
        cout << n << endl;

vector::push_back 
    automatically expands the vector if the current memory allocation is exhausted 

    while (f >> num)
        v.push_back(f):

modifying vector element- at or [i]

for (int& n:v)
    n += 2; //passby reference- it edits the variable directly

The keyword auto tells the compiler to determine the variable's type using the initial value given.
auto w = 0.5;	w	double
const auto x = 7;	x	const int

#include <iostream>
using namespace std;

int main() {
  auto x = 4.5;

  cout << typeid(x).name();

  return 0;
}

The static_cast operator (static_cast<type>(expression)) converts the expression's value to the indicated type. 
Ex: If myIntVar is 7, then static_cast<double>(myIntVar) converts int 7 to double 7.0.

   int kidsInFamily1;       // Should be int, not double
   int kidsInFamily2;       // (know anyone with 2.3 kids?)
   int numFamilies; 
   
   double avgKidsPerFamily; // Expect fraction, so double

   kidsInFamily1 = 3;
   kidsInFamily2 = 4;
   numFamilies = 2; 
   
   avgKidsPerFamily = static_cast<double>(kidsInFamily1 + kidsInFamily2)
                      / static_cast<double>(numFamilies); 

Binary
you can use binary literals using th 0b prefix

int n = 0b101;
cout << n << endl;  // 5

number = placeValue*base^placePosition (counting down to 1)

Decimal Numbers:
base = 10
212 - 2*10^2 + 1*10^1 + 2*10^0
    =    200 +   10   +   2   = 212 

Binary Numbers:
Base 2
1101 - 1*2^3 + 1*2^2 + 0*2^1 + 0*2^0
     =    8  +   4   +   0   +  1   = 13

1 2 4 8 16 32 64 128 256 512 1024 2048

A variable of char type, as in char myChar;, can store a single character like the letter m. 
A character literal is surrounded with single quotes, as in myChar = 'm';.

   char arrowBody;
   char arrowHead;

   arrowBody = '-';
   arrowHead = '>';

BINARY IN ASCII STANDARD 

010 0000	32	space
010 0001	33	!
010 0010	34	"
010 0011	35	#
010 0100	36	$
010 0101	37	%
010 0110	38	&
010 0111	39	'
010 1000	40	(
010 1001	41	)
010 1010	42	*
010 1011	43	+
010 1100	44	,
010 1101	45	-
010 1110	46	.
010 1111	47	/
011 0000	48	0
011 0001	49	1
011 0010	50	2
011 0011	51	3
011 0100	52	4
011 0101	53	5
011 0110	54	6
011 0111	55	7
011 1000	56	8
011 1001	57	9
011 1010	58	:
011 1011	59	;
011 1100	60	<
011 1101	61	=
011 1110	62	>
011 1111	63	?
100 0000	64	@
100 0001	65	A
100 0010	66	B
100 0011	67	C
100 0100	68	D
100 0101	69	E
100 0110	70	F
100 0111	71	G
100 1000	72	H
100 1001	73	I
100 1010	74	J
100 1011	75	K
100 1100	76	L
100 1101	77	M
100 1110	78	N
100 1111	79	O
101 0000	80	P
101 0001	81	Q
101 0010	82	R
101 0011	83	S
101 0100	84	T
101 0101	85	U
101 0110	86	V
101 0111	87	W
101 1000	88	X
101 1001	89	Y
101 1010	90	Z
101 1011	91	[
101 1100	92	\
101 1101	93	]
101 1110	94	^
101 1111	95	_
110 0000	96	`
110 0001	97	a
110 0010	98	b
110 0011	99	c
110 0100	100	d
110 0101	101	e
110 0110	102	f
110 0111	103	g
110 1000	104	h
110 1001	105	i
110 1010	106	j
110 1011	107	k
110 1100	108	l
110 1101	109	m
110 1110	110	n
110 1111	111	o
111 0000	112	p
111 0001	113	q
111 0010	114	r
111 0011	115	s
111 0100	116	t
111 0101	117	u
111 0110	118	v
111 0111	119	w
111 1000	120	x
111 1001	121	y
111 1010	122	z
111 1011	123	{
111 1100	124	|
111 1101	125	}
111 1110	126	~

Arrays 
arrays are part of the language, you don't have to #include anything 
they are efficieint but harder to manage- the size is fixed, they can't expand 

vectors are part of the library #include<vector> 
they have more overhead than arrays  

Arrays do not grow- once it's compiled it won't grow 
Vectors have overhead to manage automatic expansion 

you must remember the array size /keep track of the array size 

const int NUM_VALS = 4;
int courseGrades[NUM_VALS];
int i;

for (i = 0; i < NUM_VALS; ++i) {
    cin >> courseGrades[i]
}

countdown loop:
for (i = NUM_VALS; i >= 0; --i) {}

by default arrays have no initialization 
you can zero-initalize it with {}
If you don't initiaize it and you try to call it, you'll get whatever garbage is in that memory spot 

int c[] = {1,2,3};
for (auto i: c)
    cout << i << endl;

arrays can use indexing but you must not go out of bounds 
or use a range-based for loop 
functions strip arrays when you pass them in
if you go out of bounds at low level, you'll corrupt the surrounding memory

Dimensional Arrays- arrays can be nested/ have multiple dimensions 
higher dimensions are harder to visualize 

int a[2][3] = {{1,2,3}, {4,5,6}}

sizeof(myarray) in an array calculates the number of bites allocated to it //an int is 4 bites 
myarray.size() in an array tells you how many things are in the array 

c-style strings aka an array of characters 
uses \0 to mark the end of the string 
<cstring> library 

char name[4] = "Amy" ( A m y \0)

strlen strcmp strcpy strncpy strcat strncat (cstring functions) 
stoi (str to int) stof stod 

can be dangerous! 

RUNNING CODE 

g++ playground.cpp -o b 
cd C:\Users\cosse\Desktop\msys2\ucrt64\bin\projects\helloworld\ 
.\b.exe

Escape sequence	    Char
\n	                newline
\t	                tab
\'	                single quote
\"	                double quote
\\	                backslash

STRINGS 

character literals use '' string literals use ""
needs #include <string>

to get a input into a string including spaces:
getline(cin, firstString);
getline(cin, secondString);

   cout << "Enter first name:" << endl;
   getline(cin, firstName); // Gets entire line up to ENTER
   // Skip newline
    getline(cin, tmpStr);
    getline(cin, str2);

Numbers

INT Overflow- don't try to store a number larger than 2 billion in an int it will overflow and
 only store the overflow amount 
^results in a compiler warning

if you're using something that big, use a long long (that can overflow too if given a high enough value)

(*int) Unfortunately, int's size is the processor's "natural" size, and not necessarily 32 bits. 
Fortunately, nearly every compiler allocates at least 32 bits for int.

Numerical Variable Types:
Declaration	        Size	      Supported number range	             Standard-defined minimum size
char myVar;	        8 bits	      -128 to 127	                                            8 bits
short myVar;	    16 bits	      -32,768 to 32,767	                                        16 bits
long myVar;	        32 bits	      -2,147,483,648 to 2,147,483,647	                        32 bits
long long myVar;	64 bits	      -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	64 bits
int myVar;	        32 bits	      -2,147,483,648 to 2,147,483,647	                        16 bits

float x;	        32 bits	      -3.4x1038 to 3.4x1038
double x;	        64 bits	      -1.7x10308 to 1.7x10308

        mantissa is limited to about 7 significant digits for float and about 16 significant digits for double. 
        Anything with more values is truncated
        Floats store a sign(+/-), exponent(where the decimal is), and mantissa (the numerical values)

unsigned char myVar;	    8 bits	    0 to 255	                                    8 bits
unsigned short myVar;	    16 bits	    0 to 65,535	                                    16 bits
unsigned long myVar;	    32 bits	    0 to 4,294,967,295	                            32 bits
unsigned long long myVar;	64 bits	    0 to 18,446,744,073,709,551,615 	            64 bits
unsigned int myVar;	        32 bits	    0 to 4,294,967,295	                            16 bits

Order of Operations 

Operator/Convention	Description	                                    Explanation
( )             	Items within parentheses are evaluated first	In (a * (b + c)) - d, the + is evaluated first, then *, then -.
!	                ! (logical NOT) is next	! x || y is evaluated as (!x) || y
* / % + -	        Arithmetic operators (using their precedence rules; see earlier section)	z - 45 * y < 53 evaluates * first, then -, then <.
<   <=   >   >=	    Relational operators	x < 2 || x >= 10 is evaluated as (x < 2) || (x >= 10) because < and >= have precedence over ||.
==   !=	            Equality and inequality operators	x == 0 && x != 10 is evaluated as (x == 0) && (x != 10) because == and != have precedence over &&.
== and !=           have the same precedence and are evaluated left to right.
&&	                Logical AND	x == 5 || y == 10 && z != 10 is evaluated as (x == 5) || ((y == 10) && (z != 10)) because && has precedence over ||.
||	                Logical OR	|| has the lowest precedence of the listed arithmetic, logical, and relational operators.

basically P!EMDAS, Alligators, ANDS, and ORS

& and | are bitwise operators and should only be used in bitwise expressions

|   bitwise-OR                  
&   bitwise-AND              
^   bitwise-XOR
~   bitwise-NOT
>>  shift-right (multiply by 2)
<<  shift-left (divide by 2)

#include <iostream>
using namespace std;

int main() {
    auto x = byte(0b00101101);      // 45
    cout << int(x) << endl;
    auto y = byte(0b01101010);      // 106
    cout << int(y) << endl;
    cout << int(x | y) << endl;     // 01101111 = 64+32+8+4+2+1 = 111
    cout << int(x & y) << endl;     // 00101000 = 32+8 =40
    cout << int(x ^ y) << endl;     // 01000111 = 64+4+2+1 = 71

    cout << int(~x) << endl;        // 11010010 = 128+64+16+2 = 210
}

/* Output:
45
106
111
40
71
210
*/

double bang idiom:
 auto bitval = !!(n & mask);     // !32 == 0, !(!32) == !0 == 1
 to change a mask or an int into a true/false value

#include <iostream>
using namespace std;

int main() {
    int n = 0; //orig 32
    auto b = !n;        // b == false (boolean)
    auto not_b = !b;    // not_b == true (boolean)
    cout << boolalpha;  // Print bools as words
    cout << "b: " << b << ", as int: " << int(b) << endl;
    cout << "not_b: " << not_b << ", as int: " << int(not_b) << endl;
    cout << "!!n == " << !!n << ", as int: " << int(!!n) << endl;
}

To extract the lower k bits of an integer you need a mask with the lower k bits set. This is easily obtained by the expression:

    mask = (1 << k) - 1

#include <bitset>
#include <iostream>
using namespace std;

int main() {
    cout << "Enter an integer to extract from: ";
    unsigned int n;
    cin >> n;
    cout << "n = " << n << " = " << bitset<32>(n) << endl;

    cout << "Enter the number of lower bits: ";
    unsigned int k;
    cin >> k;

    unsigned int mask = (1 << k) - 1;
    auto result = n & mask;
    cout << "lower " << k << " bits unchanged: " << bitset<32>(result) << endl;
}

/*  Sample execution:
Enter an integer to extract from: 60000
n = 60000 = 00000000000000001110101001100000
Enter the number of lower bits: 10
lower 10 bits unchanged: 00000000000000000000001001100000
*/

You can extract any contiguous sequence of bits from an integer my shifting the 
 mask to the appropriate position, ANDing to extract the bits, and then shifting the results back so it is right aligned at position 0, giving the number the extracted bits represent.

Suppose, for example, the you want to extract bits 5 through 11. Remember that bit position 11 is to the left of bit position 5. The number of bits to be extracted is 
. The first step, therefore, is to create a mask with the lower 7 bits set:

mask = (1 << 7) - 1 == 00000000000000000000000001111111
Now shift to the left 5 positions so that the mask is right-aligned in bit position 5:

mask <<= 5 == 00000000000000000000111111100000
Then AND this mask with the number, getting a result of the following pattern:

temp = n & mask == 00000000000000000000#######00000
where the hash signs represent the bits extracted from the number. Finally, to get this result as a number in its own right, shift to the left 5 places to align over bit position 0:

result = temp >> 5 == 0000000000000000000000000#######
Not that it would be very readable, but you could extract bits 
 through 
 from the number n all at once as follows:

(n & (((1 << (m-k+1)) - 1) << k)) >> k

// Illustrate bitwise ops
#include <iostream>
using namespace std;

int main() {
    unsigned int n = 0x0a0b0c0d;    // = 0b0000'1010'0000'1011'0000'1100'0000'1101 = 1,684,961,410
    cout << hex;

    // Print each nybble left-to-right
    unsigned int mask = 0xf0000000;
    for (int i = 0; i < 8; ++i) {
        auto bits = mask & n;
        cout << (bits >> ((7-i)*4));   // 7-i = 8-(i+1), and there are 8 nibbles in a 32-bit int
        mask >>= 4;
    }
    cout << endl;

    // Print each bit left-to-right after flipping n's bits
    mask = 0x80000000;
    n = ~n;
    for (int i = 0; i < 32; ++i) {
        auto bits = mask & n;
        cout << !!bits;     // The first ! gives 0 or 1, the second flips to 1 or 0
        mask >>= 1;
    }
    cout << endl;
}

/* Output:
0a0b0c0d
11110101111101001111001111110010
*/

Desired Effect
Code
Test (read) the bit in position k	
n & (1 << k)
Set (to 1) the bit in position k	
n |= (1 << k)
Reset (to 0) the bit in position k	
n &= ~(1 << k)
Toggle (flip) the bit in position k	
n ^= (1 << k)
Extract the lower k bits as a new number	
n & ((1 << k) - 1)
Read the bits in positions k through m as a
number	Get a mask with 
 ones in its lower bits:
unsigned int mask = (1 << (m-k+1)) - 1;
Move the mask into position:
mask <<= k;
Do the AND:
result = n & mask
Right-align the result:
result >>= k
Same as above but all at once (not very readable)	
(n & (((1 << (m-k+1)) - 1) << k)) >> k

switch statements!!!

//the expression (a) should be an int or a char 
//ALWAYS have a default case 
switch (a) {
  case 0:
     // Print "zero"
     break;

  case 1:
     // Print "one"
     break;

  case 2:
     // Print "two"
     break;

   default:
     // Print "unknown"
     break;
}

if statements:

if (dogYears == 0) {           // Like case 0
   // Print 0..14 years
}
else if (dogYears == 1) {      // Like case 1
   // Print 15 years
}
...
else if (dogYears == 5) {      // Like case 5
   // Print 37 years 
}
else {                         // Like default case
   // Print unknown
}

//falling through- if you don't put a break statement, the code will run the next case until it hits a break
#include <iostream>
using namespace std;

int main() {
   int dogAgeYears;
   int dogAgeMonths;

   cout << "Enter dog's age (in years): ";
   cin >> dogAgeYears;

   if (dogAgeYears == 0) {
      cout << "Enter dog's age in months: ";
      cin  >> dogAgeMonths;

      switch (dogAgeMonths) {
         case 0:
         case 1:
         case 2:
            cout << "That's 0..14 human months." << endl;
            break;

         case 3:
         case 4:
         case 5:
         case 6:
            cout << "That's 1..5 human years." << endl;
            break;

         case 7:
         case 8:
            cout << "That's 5..9 human years." << endl;
            break;

         case 9:
         case 10:
         case 11:
         case 12:
            cout << "That's 9..15 human years." << endl;
            break;

         default:
            cout << "Invalid input." << endl;
            break;
      }
   }
   else {
      cout << "FIXME: Do earlier dog year cases." << endl;
      switch (dogAgeYears) {
      }
   }

   return 0;
}

Booleans!!
a variable that is either set to true or false

#include <iostream>
using namespace std;

int main() {
   int waitTime;
   int partySize;
   char day;
   bool isLargeParty;
   bool isWeekend;
   
   // Get day of reservation
   cout << "Day of reservation (T/W/R/F/S/U): ";
   cin >> day;
   if (day == 'F' || day == 'S' || day == 'U') {
      isWeekend = true;
   }
   else {
      isWeekend = false;
   }
   
   // Get party size
   cout << "Enter party size: ";
   cin  >> partySize;
   isLargeParty = (partySize > 6);
   
   // Determine wait time based on day of week and party size
   if (isWeekend && !isLargeParty) {
      waitTime = 30;
   }
   else if (!isWeekend && !isLargeParty) {
      waitTime = 10;
   }
   else if (isWeekend && isLargeParty) {
      waitTime = 45;
   }
   else {
      waitTime = 15;
   }
   
   cout << "Restaurant wait time is " << waitTime
        << " minutes." << endl;
   
   return 0;
}

string equality- if it's identical or not
string relational comparisons- goes in alphabetical order, capitals first 
    if the existing characters are equal, the smaller string is less than 

indexing strings:
cout << userWord[3]; //does not check the validity of the index 
cout << userWord.at(3); //checks the validity, returns an error if not

replace a character in a string:
userWord.at(replaceIndex) = '*';

s1.size() returns s1's length

userCaption.append("."); //add to a string, must use a string value

#include <iostream>
#include <string>
using namespace std;

int main() {
   string userCaption;
   char lastChar;
   int lastIndex;

   cout << "Enter a caption: ";
   getline(cin, userCaption);

   lastIndex = userCaption.size() - 1;
   lastChar  = userCaption.at(lastIndex);

   if ( (lastChar != '.') && (lastChar != '!') && (lastChar != '?') ) {
      // User's caption lacked ending punctuation, so add a period
      userCaption.append("."); //add to a string 
   }

   cout << "New: ";
   cout << userCaption << endl;

   return 0;
}

userText[7] = '!' may write to another variable's location and cause bizarre program behavior.

One caveat with toupper and tolower: they return integers! It is crucial in Example 3.15.1 above that the result of toupper was stored in a char variable. Otherwise, it would have printed an integer value corresponding to the character. See below:

string s = "David";

// First attempt: print letters as upper case
for (char c: s)
    cout << toupper(c);
cout << endl;

// Fix: Cast to char
for (char c: s)
    cout << char(toupper(c));
cout << endl;
Output:

6865867368
DAVID

#include <cctype> 

isalpha(c)	true if alphabetic:
a-z or A-Z	
isalpha('x') // true
isalpha('6') // false
isalpha('!') // false

toupper(c)	Uppercase version	
letter = toupper('a')  // A
letter = toupper('A')  // A
letter = toupper('3')  // 3

isdigit(c)	true if digit: 0-9.	
isdigit('x') // false
isdigit('6') // true

tolower(c)	Lowercase version	// to upper and to lower do not modify the original value 
letter = tolower('A')  // a
letter = tolower('a')  // a
letter = tolower('3')  // 3

isspace(c)	true if whitespace.	
isspace(' ')  // true
isspace('\n') // true
isspace('x')  // false

find()	find(item) returns index of first item occurrence, else returns string::npos (a constant defined in the string library). Item may be char, string variable, string literal (or char array).

find(item, indx) starts at index indx.	
// userText is "Help me!"
userText.find('p')    // Returns 3 
userText.find('e')    // Returns 1 (first occurrence of e only) 
userText.find('z')    // Returns string::npos 
userText.find("me")   // Returns 5
userText.find('e', 2) // Returns 6 (starts at index 2)
substr()	substr(index, length) returns substring starting at index and having length characters.	
// userText is "http://google.com"
userText.substr(0, 7)                     // Returns "http://"
userText.substr(13, 4)                    // Returns ".com"
userText.substr(userText.size() - 4, 4)   // Last 4: ".com"

